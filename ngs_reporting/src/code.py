#!/usr/bin/env python
# ngs_reporting_oncology 0.0.1
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# See https://wiki.dnanexus.com/Developer-Portal for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

from __future__ import print_function
import os
import dxpy
import subprocess
import re
import time
import glob

PATTERN_MAPPING = {
    re.compile('^file-[0-9A-Za-z]{24}$'): dxpy.DXFile
}


def download_job_inputs(input_dict):
    """Download files objects and update job input dict
    Updates all values that contain a dxlink
    """
    def create_dx_data_obj(inp_val):
        # TODO support getting outgoing file-id from DXRecords
        if type(inp_val) is not dict or '$dnanexus_link' not in inp_val:
            return
        dx_id = inp_val['$dnanexus_link']
        for reg_obj, dxmatch in PATTERN_MAPPING.iteritems():
            if reg_obj.match(dx_id):
                return dxmatch(dx_id)
    for inp_name, val in input_dict.iteritems():
        f_dx = create_dx_data_obj(val)
        print("f_dx: " + str(f_dx))
        if f_dx is not None:
            f_path = f_dx.name
            dxpy.download_dxfile(f_dx, f_path)
            input_dict[inp_name] = {
                "dxFileObj": f_dx,
                "filePath": f_path
            }
    return input_dict


def get_opts(updated_input_dict):
    """Add optional parameters"""
    OPT_CMD = {
        # 'sys_info_yaml': '--sys-cfg {param}',
    }
    cmd_opt = []
    for inp, val in updated_input_dict.iteritems():
        opt_str = OPT_CMD.get(inp)
        if opt_str is None:
            continue
        param = val.get('filePath') if type(val) is dict else val
        cmd_opt.append(opt_str.format(param=param))
    return cmd_opt


def run_cmdl(cmdl):
    print(" ".join(cmdl))
    subprocess.check_call(cmdl)


@dxpy.entry_point('main')
def main(**job_inputs):
    print('PATH = ' + str(os.environ['PATH']))
    os.environ['PATH'] += os.pathsep + '/miniconda/envs/ngs_reporting/bin' + os.pathsep + '/miniconda/bin'
    os.environ['CONDA_DEFAULT_ENV'] = 'ngs_reporting'
    print('PATH = ' + str(os.environ['PATH']))
    run_cmdl(['which', 'bcbio_postproc'])
    run_cmdl(['bcbio_postproc', '--version'])

    # print()
    # print('Removing NGS_Reporting from conda envirnoment to reinstall it from source')
    # run_cmdl(["conda", "remove", "ngs_reporting", "-y"])
    # print('Cloning the repository to get the latest source code')
    # run_cmdl(["git", "clone", "https://github.com/AstraZeneca-NGS/NGS_Reporting"])
    # os.chdir("NGS_Reporting")
    # run_cmdl(["pip", "install", "--upgrade", "pip"])
    # run_cmdl(["pip", "install", "--upgrade", "--ignore-installed", "setuptools"])
    # run_cmdl(["python", "setup.py", "install"])
    # os.chdir("..")
    # run_cmdl(['which', 'bcbio_postproc'])
    # run_cmdl(['bcbio_postproc', '--version'])

    print()
    sys_yaml = '/reference_data/system_info_DNAnexus.yaml'
    if os.path.isfile(sys_yaml):
        print('Sys yaml ' + sys_yaml + ' exists')
    else:
        print('Sys yaml ' + sys_yaml + ' does not exist')

    postproc_cmdl = ['bcbio_postproc', '--sys-cfg', sys_yaml]

    print("job_inputs: " + str(job_inputs))
    job_inputs = download_job_inputs(job_inputs)
    print("updated job_inputs: " + str(job_inputs))
    postproc_cmdl.extend(get_opts(job_inputs))

    bcbio_dir = job_inputs['bcbio_dir']
    if not bcbio_dir.startswith('/'):
        bcbio_dir = '/' + bcbio_dir
    print('Calling download_platform_folder_with_exclusion')
    copy_folder_to_proj(src_proj=os.environ['DX_PROJECT_CONTEXT_ID'], src_proj_fld=bcbio_dir, target_fld_prefix='')

    print('Bcbio directory:', bcbio_dir)
    postproc_cmdl.append(bcbio_dir)

    print('Runing post-processing with the command: "' + " ".join(postproc_cmdl) + '"')
    subprocess.check_call(postproc_cmdl)

    ##### Output files ####
    report_file_links = []
    print('Uploading output files')

    # HTML reports
    multiqc_report = glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "report.html"))
    if not multiqc_report:     
        print('Error: report.html not found for project ' + bcbio_dir)
        sys.exit(1)
    multiqc_report = multiqc_report[0]
    print('MultiQC report: ' + multiqc_report)

    files_linked_to_multiqc = (
        glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "call_vis.html")) +  # remove this line after update
        glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "call_vis.part1.html")) +  # remove this line after update
        glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "reports", "*.html")) +
        glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "var", "vardict.PASS.txt")) +
        glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "var", "vardict.paired.PASS.txt")) +
        glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "var", "vardict.single.PASS.txt")) +
        glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "cnv", "seq2c.tsv")) +
        glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "log", "programs.txt")) +
        glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "log", "data_versions.csv")))

    url_mapping = dict()
    print('Other reports:')
    for path in files_linked_to_multiqc:
        print('  ' + path)
        dxlink = dxpy.dxlink(dxpy.upload_local_file(filename=path, folder=os.path.dirname(path), parents=True))
        report_file_links.append(dxlink)
        dxurl = 'https://platform.dnanexus.com/' + os.environ['DX_PROJECT_CONTEXT_ID'] + '/' + dxlink['$dnanexus_link'] + '/view'
        relpath = os.path.relpath(path, os.path.dirname(multiqc_report))
        url_mapping[relpath] = dxurl

    print('Fixing links to reports in the MultiQC report')
    replace_in_file(multiqc_report, url_mapping)
    dxlink = dxpy.dxlink(dxpy.upload_local_file(filename=multiqc_report, folder=os.path.dirname(multiqc_report), parents=True))
    report_file_links.append(dxlink)

    # Other output files
    print('Other files:')
    for path in (
            glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "var", "*.txt")) +
            glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "var", "*.vcf.gz*")) +
            glob.glob(os.path.join(bcbio_dir, "final*", "20??-??-??_*", "cnv", "*")) +
            glob.glob(os.path.join(bcbio_dir, "final*", "*", "varFilter", "*")) +
            glob.glob(os.path.join(bcbio_dir, "final*", "*", "*.anno.filt.vcf.gz*"))):
        relpath = os.path.relpath(path, os.path.dirname(multiqc_report))
        if relpath not in url_mapping:  # file not yet uploaded
            print('  ' + path)
            dxlink = dxpy.dxlink(dxpy.upload_local_file(filename=path, folder=os.path.dirname(path), parents=True))
            report_file_links.append(dxlink)

    output = {'report_files': report_file_links}

    return output


def replace_in_file(fpath, url_mapping):
    with open(fpath, 'r') as file:
        filedata = unicode(file.read(), 'utf-8')
    for old, new in url_mapping.items():
        print('  replace ' + old + ' -> ' + new)
        filedata = filedata.replace(old, new)
    with open(fpath, 'w') as file:
        file.write(filedata.encode('utf-8'))


def copy_folder_to_proj(src_proj, target_proj=None, src_proj_fld=None, target_fld_prefix=None, exclude_func=None):
    """Copies folder from src_proj to target_proj under target_proj_fld_prefix
    Args:
            target_proj: Destination project. If not specified local machine is assumed.
            src_proj_fld: Source folder to copy from. If None, project root is assumed.
            target_fld_prefix: Prefix to prepend to copied folders. Defaults to Root if not specified
            exclude_func: func that is passed the describe results of a dxobject and returns a boolean.
                True - file is copied, False - Not copied over.
    """
    def transfer_to_project(file_id, file_dxpath, file_name):
        f_dx = dxpy.DXFile(file_id, project=src_proj)
        prefix = "/" if target_fld_prefix is None else target_fld_prefix
        file_dxpath = os.path.join(prefix, file_dxpath)
        file_platform_url = f_dx.get_download_url(duration=3600, preauthenticated=True)[0]
        url_fetcher_input = {'url': file_platform_url, 'output_name': file_name}
        url_fetcher_appdx.run(
            app_input=url_fetcher_input, project=target_proj,
            folder=file_dxpath)

    def download_to_local(file_id, file_dxpath, file_name):
        # Just creating a directory for saftey
        prefix = "Downloaded_Files_dir_{}".format(time.time()) if target_fld_prefix is None else target_fld_prefix
        file_dir = os.path.join(prefix, file_dxpath)
        if not os.path.exists(file_dir):
            os.makedirs(file_dir)
        file_download_path = os.path.join(file_dir, file_name)
        if os.path.isfile(file_download_path):
            print('Found {fn} at {fpath}'.format(
                fn=file_name, fpath=file_download_path))
            return
        print('downloading {fn} to {fdir}'.format(
            fn=file_name, fdir=file_dir))
        dxpy.download_dxfile(file_id, file_download_path)

    url_fetcher_appdx = dxpy.DXApp('app-F4qJ1189b249vy69G1vF5jqf')
    fetch_func = download_to_local if target_proj is None else transfer_to_project

    file_describes = dxpy.find_data_objects(
        classname='file', state='closed', visibility='visible',
        project=src_proj, folder=src_proj_fld, describe=True)

    for file_describe in file_describes:
        if exclude_func is not None and exclude_func(file_describe):
            continue
        fetch_func(
            file_id=file_describe['id'],
            file_dxpath=file_describe['describe']['folder'],
            file_name=file_describe['describe']['name'])


dxpy.run()
